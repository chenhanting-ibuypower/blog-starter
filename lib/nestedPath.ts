import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { trimChar } from "./utilities";

// Recursivly scan the documentation folder. This includes any extra resolution magic
// such as index.md acting as the folder index
async function getNestedPathList(folder, ogPath, pageFileCache) {
    return (
        await Promise.all(
            (await fs.readdirSync(folder)).map(async (file) => {
                const joined = path.join(folder, file);

                //  Call recursively if a directory
                if ((await fs.statSync(joined)).isDirectory()) {
                    return getNestedPathList(joined, ogPath, pageFileCache);
                }

                // If a content markdown is found
                if (joined.endsWith('.md')) {
                    let alteredPath = joined
                        .slice(folder.length + 1)
                        .replace(/\.md$/, '')
                        .replace(/\index$/, '');

                    // In recursive depths, add folder name and trim any stray '/'
                    if (folder !== ogPath) {
                        alteredPath = folder.replace(ogPath, '') + '/' + alteredPath;
                    }
                    alteredPath = trimChar(alteredPath, '/');

                    pageFileCache[alteredPath] = joined;
                    return {
                        params: {
                            id: alteredPath.split('/'),
                        },
                    };
                } else {
                    return null;
                }
            })
        )
    ).filter((x) => !!x);
}

// Generate nested data from nested paths and pageFileCache
// Input paths, pageFileCache generated by getNestedPathList()
function nestData(paths, pageFileCache, start = ['']) {
    // console.log("paths:", path)
    let files = [];
    let startPath = pageFileCache[start.join('/')];

    // Remove the element start by compairing ID array
    paths = paths.filter((p) => {
        return (
            Array.isArray(p) ||
            !(
                p.params.id.length === start.length &&
                p.params.id.every((value, index) => value === start[index])
            )
        );
    });
    // printPaths(paths)

    for (let path of paths) {
        if (!Array.isArray(path)) {
            let id = path.params.id.join('/');
            let fullPath = pageFileCache[id];
            // Use gray-matter to parse the post metadata section
            // console.log("fullPath & id:", id, fullPath)
            const fileContents = fs.readFileSync(fullPath, 'utf8');
            const matterResult = matter(fileContents);

            // console.log("pageFileCache[id]:", pageFileCache[id])
            files.push({
                type: 'file',
                id,
                path: pageFileCache[id],
                matter: matterResult.data,
            });
        } else {
            // New start will have smallest id length
            let newStart = path.reduce((str, p) => {
                if (!Array.isArray(p)) {
                    if (Array.isArray(str)) {
                        return p;
                    }
                    return str.params.id.length < p.params.id.length ? str : p;
                }
                return str;
            }).params.id;

            files.push(nestData(path, pageFileCache, newStart));
        }
    }

    // Use gray-matter to parse the post metadata section

    let matterResult: any = { data: "" }
    if(startPath) {
        const fileContents = fs.readFileSync(startPath, 'utf8');
        matterResult = matter(fileContents);
    }

    return {
        type: 'folder',
        id: start.join('/'),
        path: startPath ?? "",
        matter: matterResult.data,
        files: files,
    };
}

export async function getFolderNestedData(folder) {
    let fullFolderPath = path.join(process.cwd(), '/' + folder);

    const pageFileCache = {};
    const paths = await getNestedPathList(
        fullFolderPath,
        fullFolderPath,
        pageFileCache
    );

    return nestData(paths, { ...pageFileCache });
}